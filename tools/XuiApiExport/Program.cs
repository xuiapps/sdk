using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

/// <summary>
/// Scans Xui source projects, strips all method/constructor/accessor bodies to semicolons
/// (interface-style), preserves XML doc comments, and writes individual .cs files to
/// www/api/{ProjectName}/{relative-path}.cs for embedding in the Xui MCP server.
///
/// Usage: dotnet run [solutionRoot]
/// Default solutionRoot: current working directory (run from repo root)
/// </summary>

var root = args.Length > 0 ? Path.GetFullPath(args[0]) : Directory.GetCurrentDirectory();
var outputBase = args.Length > 1 ? Path.GetFullPath(args[1]) : Path.Combine(root, "www", "api");

var projects = new Dictionary<string, string>
{
    ["Xui.Core"]                = Path.Combine(root, "Xui", "Core", "Core"),
    ["Xui.Core.DI"]             = Path.Combine(root, "Xui", "Core", "Core.DI"),
    ["Xui.Middleware.Emulator"] = Path.Combine(root, "Xui", "Middleware", "Emulator"),
};

Console.Error.WriteLine($"Exporting Xui API to {outputBase}...");
var totalFiles = 0;

foreach (var (projectName, projectDir) in projects)
{
    if (!Directory.Exists(projectDir))
    {
        Console.Error.WriteLine($"  Skipping {projectName} — not found: {projectDir}");
        continue;
    }

    Console.Error.WriteLine($"  {projectName}...");
    var projectFiles = 0;

    foreach (var file in Directory.GetFiles(projectDir, "*.cs", SearchOption.AllDirectories).Order())
    {
        var relPath = Path.GetRelativePath(projectDir, file);
        if (relPath.StartsWith("obj" + Path.DirectorySeparatorChar)) continue;

        var fileName = Path.GetFileName(file);
        if (fileName.Equals("AssemblyInfo.cs", StringComparison.OrdinalIgnoreCase)) continue;

        var text = File.ReadAllText(file);

        // Skip auto-generated files (check first 200 chars)
        if (text.AsSpan(0, Math.Min(200, text.Length)).Contains("<auto-generated", StringComparison.Ordinal))
            continue;

        var tree = CSharpSyntaxTree.ParseText(text);
        var rewriter = new BodyStripper();
        var stripped = rewriter.Visit(tree.GetRoot())!.NormalizeWhitespace().ToFullString();

        var outPath = Path.Combine(outputBase, projectName, relPath);
        Directory.CreateDirectory(Path.GetDirectoryName(outPath)!);
        File.WriteAllText(outPath, stripped);
        projectFiles++;
    }

    Console.Error.WriteLine($"    → {projectFiles} files");
    totalFiles += projectFiles;
}

Console.Error.WriteLine($"Done — {totalFiles} files total.");

/// <summary>
/// Replaces all method/constructor/accessor/operator bodies with a semicolon,
/// producing interface-style declarations. XML doc comments are preserved as trivia.
/// </summary>
class BodyStripper : CSharpSyntaxRewriter
{
    static readonly SyntaxToken Semi = SyntaxFactory.Token(SyntaxKind.SemicolonToken);
    static readonly SyntaxToken None = SyntaxFactory.Token(SyntaxKind.None);

    public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitMethodDeclaration(node);
    }

    public override SyntaxNode? VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitConstructorDeclaration(node);
    }

    public override SyntaxNode? VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitDestructorDeclaration(node);
    }

    public override SyntaxNode? VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitAccessorDeclaration(node);
    }

    public override SyntaxNode? VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitOperatorDeclaration(node);
    }

    public override SyntaxNode? VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
        if (node.Body != null || node.ExpressionBody != null)
            node = node.WithBody(null).WithExpressionBody(null).WithSemicolonToken(Semi);
        return base.VisitConversionOperatorDeclaration(node);
    }

    // Expression-bodied property (=> value) → convert to { get; } accessor list
    public override SyntaxNode? VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        if (node.ExpressionBody != null)
        {
            var getter = SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                .WithSemicolonToken(Semi);
            node = node
                .WithAccessorList(SyntaxFactory.AccessorList(SyntaxFactory.List(new[] { getter })))
                .WithExpressionBody(null)
                .WithSemicolonToken(None);
        }
        return base.VisitPropertyDeclaration(node);
    }

    // Expression-bodied indexer → convert to { get; } accessor list
    public override SyntaxNode? VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
        if (node.ExpressionBody != null)
        {
            var getter = SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                .WithSemicolonToken(Semi);
            node = node
                .WithAccessorList(SyntaxFactory.AccessorList(SyntaxFactory.List(new[] { getter })))
                .WithExpressionBody(null)
                .WithSemicolonToken(None);
        }
        return base.VisitIndexerDeclaration(node);
    }
}
